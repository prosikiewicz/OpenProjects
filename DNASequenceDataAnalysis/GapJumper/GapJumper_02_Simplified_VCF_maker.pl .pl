#!/usr/bin/perl

use strict;
use warnings;
use Data::Dumper;
use Sort::Naturally;


my $numArgs = $#ARGV + 1;

unless( $numArgs == 3) {
    
    print "\n";    
    print "===============================================================================\n";
    print "Usage: perl $0   All_positions_with_variants_201XXXXX.combinedVCF   ***.coverage   ***.VCF\n";
    print "\n";
    print "===============================================================================\n";
    print "   Author: Frederic Masclaux\n";
    print "   Date: 2016-06-08\n";
    print "   Version: 1\n";
    print "   Name: $0\n";
    print "   Purpose: \n";
    print "   Record all variants from a VCF file \n";
    print "   Create a simplified VCF file\n";      
    print "   Comments :\n";
    print "===============================================================================\n";
    exit;
}

my $version = "v1.0";

#.....Variables.....#

my @int1;

my (@interm, @interm2,@interm3, @interm4);

my %record;

my $scaffold; 
my $position;

my $cursor_type;

my @AlleleType;
my @AlleleCompo;
my @AlleleCov;

my %RecAtPos;
my $count;

my $REFallele;
my $long;

my $total_cov;

my$DP;


#..................#



warn "\n","*********************","\n";
##############################################################################################################
#####....................................................................................................#####

warn "Input and output files\n\n";

#####....................................................................................................#####
##############################################################################################################

my ($All_pos_file, $coverage_file, $VCF_file) = @ARGV;


#input

open (IN1, $All_pos_file) || die "Can't open $All_pos_file: $!";
open (IN2, $coverage_file) || die "Can't open $coverage_file: $!";
open (IN3, $VCF_file) || die "Can't open $VCF_file: $!";

#sample name
@int1 = split(/\./,$coverage_file);
my $SampleName = $int1[0];

#output
my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
my $date =  sprintf ("%04d%02d%02d",$year+1900,$mon+1,$mday);
my $NameOUT1 = $SampleName . "_" . $date . ".simplifiedVCF";
open (OUT1, ">$NameOUT1")  || die "Can't open $NameOUT1: $!";


#test the location of TYPE in the .vcf file generated by Freebayes
foreach my $line (<IN3>) {
   chomp($line);
    
   if ($line =~ /^\s*#/) {
      next;
	
   } elsif ($line =~ /^\s*$/) {
      next;
	
   } else {
	@interm = split(/\s/,$line);
	@interm2 = split(/;/,$interm[7]);
	$cursor_type = 0;
	foreach my $t (@interm2){
      if ($t =~ m/TYPE/) {
         last;
      }
      $cursor_type ++
	}
	@interm3 = split(/=/,$interm2[$cursor_type]);	    
	if ($interm3[0] ne "TYPE"){
	   warn "error in recording TYPE"; die;
	}
    }
   if ($cursor_type > 0) {
      last;
   }
}
close(IN3);



warn "\n","*********************","\n";
##############################################################################################################
#####....................................................................................................#####

warn "  Parsing first file : $All_pos_file   ########################## \n\n";

#####....................................................................................................#####
##############################################################################################################


foreach my $line (<IN1>) {
   chomp($line);
   
   @interm = split(/\t/, $line);
    
   if 	($line =~ /^\s*#/) {
      next;			
            
   # discard blank line
   } elsif ($line =~ /^\s*$/) {
      next;	
		
   } elsif ($interm[2] ne "----") {

      $record{$interm[0]}{positions}{$interm[2]}{RADname} = $interm[1];
      $record{$interm[0]}{positions}{$interm[2]}{seqID} = $interm[3]; 
      $record{$interm[0]}{positions}{$interm[2]}{cluster} = $interm[4];
      $record{$interm[0]}{positions}{$interm[2]}{repeat} = $interm[5];
      $record{$interm[0]}{positions}{$interm[2]}{coding} = $interm[6];
      $record{$interm[0]}{positions}{$interm[2]}{REF} = $interm[7];
     
      $record{$interm[0]}{positions}{$interm[2]}{coverage} = 0;
   }

}



warn "\n","*********************","\n";
##############################################################################################################
#####....................................................................................................#####

warn "  Parsing second file : $coverage_file   ########################## \n\n";

#####....................................................................................................#####
##############################################################################################################


foreach my $line (<IN2>) {
   chomp($line);
   @interm = split(/\t/, $line);
   
   if (exists $record{$interm[0]}){
      if (exists $record{$interm[0]}{positions}{$interm[1]}) {
         $record{$interm[0]}{positions}{$interm[1]}{coverage} = $interm[2];
      }
   }

}



warn "\n","*********************","\n";
##############################################################################################################
#####....................................................................................................#####

warn "  Parsing VCF file : $VCF_file   ########################## \n\n";

#####....................................................................................................#####
##############################################################################################################

    
open (IN3, $VCF_file) || die "Can't open $VCF_file: $!";     # RE-open the file

foreach my $line (<IN3>) {
   chomp($line);
    
   if ($line =~ /^\s*#/) {
      next;
        
   } elsif ($line =~ /^\s*$/) {
      next;
        
   } else {
      $line =~ s/:/;/g;		# all : used by freebayes in its specific fields are replaced with ; as in the standard VCF
      $line =~ s/,/:/g;		# all , are replaced by : . They are used to separate 2 ALT alleles. , is a problem for table (@...)
      #warn "$line\n";        
      @interm = split(/\s/,$line);
              
      #Scaffold and position
      $scaffold = $interm[0];
      $position = $interm[1];
 
      if (exists $record{$scaffold}) {
         if (exists $record{$scaffold}{positions}{$position}) {
      
            @AlleleType = ();
            @AlleleCompo = ();
            @AlleleCov = ();
            %RecAtPos = ();
            $DP = "";
        
            @interm2 = split(/;/,$interm[7]);
            @interm3 = split(/=/,$interm2[$cursor_type]);	    
  
              
          #---# Record REF type, REF compo and REF allele
            $RecAtPos{0}{type} = "R";
            
            $REFallele = $interm[3];
            $RecAtPos{0}{compo} = substr($REFallele, 0,1);
            
            @interm2 = split(/;/,$interm[9]);          #  ex: 0/0/0/1/1/1/1/1/1/1:59:8:520:51:1871
            
            if ($interm2[0] =~ m/0/) {
               $RecAtPos{0}{cov} = $interm2[2];
            } else {
               $RecAtPos{0}{cov} = 0;
            }
            $DP = $interm2[1];
            
        #---# Record allele type, compo and coverage	    
            @AlleleType = split(/:/ , $interm3[1]);
            $count=1;
            foreach my $t (@AlleleType) {
               $RecAtPos{$count}{type} = uc(substr($t,0,1));
               $count ++;
            }
            
            @AlleleCompo = split(/:/,$interm[4]);
            $count=1;
            foreach my $t (@AlleleCompo) {
               $RecAtPos{$count}{compo} = $t;
               $count ++;
            }
            
            @AlleleCov = split(/:/, $interm2[4]);
            $count=1;
            foreach my $t (@AlleleCov) {
               $RecAtPos{$count}{cov} = $t;
               $count ++;
            }
              
            #warn Dumper(\%RecAtPos); getc();
              
      
          #---# Control and filtering
          
            $total_cov = 0;
            foreach my $t (keys %RecAtPos) {
            
               # Format deletions
               if ($RecAtPos{$t}{type} eq "D") {
                  $long = length($REFallele) - length($RecAtPos{$t}{compo});
                  $RecAtPos{$t}{compo} = substr($REFallele, 0,1) . "-" . $long;
               }
               
               # Check if S alleles are not longer than 1 bp
               if (($RecAtPos{$t}{type} eq "S") and (length($RecAtPos{$t}{compo}) > 1)){
                  $RecAtPos{$t}{compo} = substr($RecAtPos{$t}{compo}, 0,1);
               }
               
               # Control if REF allele is not present in ALT alleles
               if (($RecAtPos{$t}{type} eq "S") and ($RecAtPos{$t}{compo} eq $RecAtPos{0}{compo})){
                  $RecAtPos{0}{cov} += $RecAtPos{$t}{cov};
                  $RecAtPos{$t}{cov} = 0 ;
               }
               if ($t != 0) {
                  $total_cov += $RecAtPos{$t}{cov};
               }
            
            }
            
            if ($total_cov >= 10 ) {
               foreach my $t (nsort keys %RecAtPos) {
                  if ($RecAtPos{$t}{cov} > 0) {
                     $record{$scaffold}{positions}{$position}{types} .= $RecAtPos{$t}{type} .",";
                     $record{$scaffold}{positions}{$position}{alleles} .= $RecAtPos{$t}{compo} .",";
                     $record{$scaffold}{positions}{$position}{occurrences} .= $RecAtPos{$t}{cov} .",";
                    
                  }
               }
            
               $record{$scaffold}{positions}{$position}{types} = substr($record{$scaffold}{positions}{$position}{types},0,-1); # remove last comma
               $record{$scaffold}{positions}{$position}{alleles} = substr($record{$scaffold}{positions}{$position}{alleles},0,-1); # remove last comma
               $record{$scaffold}{positions}{$position}{occurrences} = substr($record{$scaffold}{positions}{$position}{occurrences},0,-1); # remove last comma
                
               $record{$scaffold}{positions}{$position}{REF} = substr($REFallele, 0,1);
            
            } else {

               $record{$scaffold}{positions}{$position}{types} = "";
               $record{$scaffold}{positions}{$position}{alleles} = "na";
               $record{$scaffold}{positions}{$position}{occurrences} = $total_cov;
                
               $record{$scaffold}{positions}{$position}{REF} = substr($REFallele, 0,1);
            }
         }
      }

   }
}
    
    


foreach my $scaffold ( nsort (keys %record)) {
   foreach my $position (nsort (keys %{$record{$scaffold}{positions}})) {
      if (!exists $record{$scaffold}{positions}{$position}{alleles}) {
         if ($record{$scaffold}{positions}{$position}{coverage} >=10) {

            $record{$scaffold}{positions}{$position}{alleles} = $record{$scaffold}{positions}{$position}{REF};
            $record{$scaffold}{positions}{$position}{occurrences} ="";
            $record{$scaffold}{positions}{$position}{types} = "";
		
         } else {
            $record{$scaffold}{positions}{$position}{alleles} = "na";
            $record{$scaffold}{positions}{$position}{occurrences} ="";
            $record{$scaffold}{positions}{$position}{types} = "";
         }
      }
   }
} 
                
                
warn "\n","*********************","\n";
##############################################################################################################
#####....................................................................................................#####

warn "  Write the output file : $NameOUT1   ########################## \n\n";

#####....................................................................................................#####
##############################################################################################################


print OUT1 "Replicate_name\tScaffold\tLocus\tPosition\tseqID\tx1\tx2\tx3\tRef\tType_Alleles\tAlleles\tOccurrence_Alleles\tGeneral_coverage\n";

foreach my $scaffold ( nsort (keys %record)) {
   foreach my $position (nsort (keys %{$record{$scaffold}{positions}})) {
      print OUT1 "$SampleName\t$scaffold\t",
      $record{$scaffold}{positions}{$position}{RADname},
      "\t$position\t",
      $record{$scaffold}{positions}{$position}{seqID}, "\t", $record{$scaffold}{positions}{$position}{cluster}, "\t",
      $record{$scaffold}{positions}{$position}{repeat}, "\t", $record{$scaffold}{positions}{$position}{coding}, "\t",
      $record{$scaffold}{positions}{$position}{REF}, "\t";
      if (exists $record{$scaffold}{positions}{$position}{alleles}) {
         print OUT1 $record{$scaffold}{positions}{$position}{types},"\t", $record{$scaffold}{positions}{$position}{alleles}, "\t", $record{$scaffold}{positions}{$position}{occurrences}, "\t", $record{$scaffold}{positions}{$position}{coverage}, "\n";
      } else {
         print OUT1 "\t", "\t", $record{$scaffold}{positions}{$position}{coverage}, "\n";
      }
   }
}




__END__


